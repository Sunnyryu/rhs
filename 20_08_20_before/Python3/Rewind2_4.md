## Rewind2

#### Python

```python 

# 객체 , 클레스
# 객체 - 실생활에 존재하는 실제적인 물건 또는 개념(object) / 속성(attribute / 객체가 가지고 있는 변수 ) / 행동(action(객체가 실제로 작동할 수 있는 함수, 메서드))

#  파이썬의 객체 지향 프로그래밍 

#  클래스 ! / snake_case나 CamelCase => _를 추가하여 변수의 이름을 지정함 / 띄어쓰기 부분에 대문자를 사용하여 변수의 이름을 지정함 !!

# 속성에 대한 정보를 선언하기 위해서는 __init__()이라는 예약 함수를 사용하며 , 예약함수는 __str__, __add__ 등이 있음 / __init__() 함수는 class에서 사용할 변수를 정의하는 함수 / self 변수를 사용해야함 !! self 변수는 클래스에서 생성된 인스턴스에 접근하는 예약어 !!

# _의 쓰임 =>개수에 따라 여러가지 쓰일 수 있음 _ 1갠느 이후에 쓰이지 않을 변수에 특별한 이름을 부여하고 싶지 않을 때 쓰임 !! / __ 2개를 사용하면 특수한 예약 함수나 변수에 사용하기도 함 !! 
# __str__() 함수는 클래스로 인스턴스를 생성했을 때, 그 인스턴스 자체를 print() 함수로 화면에 출력하면 나오는 값을 뜻함 !! 

# 인스 턴스 사용하기 !

class SoccerPlayer(object):
    def __init__(self, name, position, back_number):
        self.name = name
        self.position = position
        self.back_number = back_number 
    def change_back_number(self, new_number):
        print("선수의 등번호를 변겨안다: From %d to %d" % (self.back_number, new_number))
        self.back_number =new_number
    def __str__(self):
        return "Hello, My name is %s. I play in %s in center. " % (self.name, self.position)


sunny = SoccerPlayer("sunny", "FW", 11)
print("현재 선수의 등번호는:", sunny.back_number)
sunny.change_back_number(7)
print("현재 선수의 등번호는 :", sunny.back_number)

#>>> print("현재 선수의 등번호는:", sunny.back_number)
#현재 선수의 등번호는: 11
#>>> sunny.change_back_number(7)
#선수의 등번호를 변겨안다: From 11 to 7
#>>> print("현재 선수의 등번호는 :", sunny.back_number)
#현재 선수의 등번호는 : 7

# 상속  - 부모 클래스에 정의된 속성과 메서드를 자식 클래스가 물려받아 사용하는 것이다. 파이썬 클래스를 만들 때 코드를 다음과 같이 작성할 것을 기억한다.

class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age 

class Korean(Person):
    pass 

first_korean = Korean("sunny", 27)
print(first_korean.name)
# sunny

# 다형성  / 같은 이름의 메서드가 다른 기능을 할 수 있도록 하는 것 !!

#  가시성 / 객체의 정볼르 볼 수 있는 레벨을 조절하여 객체의 정보 접근을 숨기는 것이라고 함 / 캡슐화와 은닉 .. 

# 캡슐화는 클래스 간 간섭 및 정보 공유를 최소화하여 개별 클래스가 단독으로도 잘 동작할 수 있도록 해야 하기 떄문임 !!

#  클래스 외부에서 정보를 사용하기 위해서는 데코레이터라고 불리는 @property를 사용해야한다. 클래스 상단에 상입하며 해당 메서드의 기능을 추가하는 파이썬 문법 !!

# 모듈 / 패키지 

# 모듈은 작은 프로그램 조각 !? / 인터페이스 => 간단하게 표현하면 함수에서 매개변수를 입력하는 약속 ! / 모듈간의 ㅇ녀결을 위한 약속이 인터페이스 !!

# 패키지는 모듈의 묶음 / 모듈을 호출하기 위해 패키지부터 호출하는 것이 from 

# 네임스페이스 => 모듈 호출의 범위 지정 !/ 모듈 이름에 알리아스를 생성하여 모듈 안으로 코드를 호출하는 방법 

# 파이썬은 자체적으로 설치하지 않고 사용가능한 내장 모듈이 있음 !!

# 절대참조 / 상태 참조

# 절대 참조는 전체 경로를모두 입력하는 거임 ! / 상대 참조는 현재의 디렉터리를 기준으로 모듈을 호출하는 것이라고 생각하자 !

# 예외 처리 

# try- except 
#try: 예외 발생 가능 코드 / except 에외 타입: 예외 발생 시 실행되는 코드 !!
for i in range(10):
  try:
    print(10/i)
  except ZeroDivisionError:
    print('error')
#error
#10.0
#5.0
#3.3333333333333335
#2.5
#2.0
#1.6666666666666667
#1.4285714285714286
#1.25
#1.1111111111111112
# 예외의 종류 indexError => 인덱스 범위 넘어갈 때 / NameError => 존재하지 않는 변수 호출 / ZeroDivisionError =: 0으로 나눌 때 / ValueError => 변환할 수 없는 문자나 숫자 변환 시 ! /FileNotFoundError => 존재하지 않는 

# try - except - else:
try: 
  print("예외 발생 가능 코드")
except:
  print("예외 발생 시 실행되는 코드")
else:
  print(" 에외 가 발생하지 않을 때 쓰이는 코드 !!")

#try- except - finally 문 
try: 
  print("예외 발생 가능 코드")
except:
  print("예외 발생 시 실행되는 코드")
finally:
  print(" 에외 발생 여부와 상관없이 실행되는 코드 ! !!")

# raise 문 => 필요할 때 발생시키는 코드임 !!  raise 예외타입 (정보)

# assert문 => 미리 알아야 할 예외 정보가 조건을 만족하지 않을 경우 예외를 발생시키는 문임 ! => assert 예외 조건  

# 파일 (크게 바이너리 파일과 텍스트 파일로 구분함 => 바이너리 파일은 이진 정보로 저장된 파일이며, 텍스트 파일은 사람이 이해할 수 있는 문자열로 저장된 파일 )

# 퍄일 읽기는 open() 함수를 사용함 
#f = open("파일명", "파일 열기 모드") f.close() / r = 읽기 모드 / w = 쓰기모드 / a = 추가모드 파일의 마지막에 새로운 내용을 추가할 때 씀 !!

# with 문과 함꼐 사용  => with문은 들여쓰기를 사용해 들여쓰기가 있는 코드에서는 open 함수 유지 .. 종료되면 open()함수도 끝 !! 
with open("a.txt","r") as my_file:
  contents = my_file.read()
  print(type(contents), contents)

# 한 줄씩 읽어서 리스트형으로 바꾸려면 read() 함수대신에 readlines() 함수를 사용하면 굿 !

# 실행할 때 마다 한줄씩 읽어오려면 readline()함수를 사용 !

# 파일 안글자의 통계 정보 출력시에는 split으로 한줄단위나 단어 단위로 쪼개고 len으로 구하면 굿!! 

#w 로 파일을 쓰거나 a를 이용해 새로운 글 추가할 수 있음 !

# 디렉토리를 만들떄는 파이썬 내장 모듈인 os를 사용해서 os.mkdir을 사용하여 만들 수 있음 / 

# pickle 모듈 => 메모리에 로딩된 객체를 영속화할 수 있도록 지원함 ( 영속화는 필요한 객체를 파일로 저장하여 다시 사용할 수 있도록 하는 거임 ! / wb나 rb 같이 쓰는 바이너리 / 읽는 바이너리라고 할 수 있다 )

# csv => 콤마를 기준으로 나누어진 데이터라고 생각해보자 ! 

#  파일 객체나 csv 객체 , 판다스 객체를 사용 함 !

# 파일 객체를 이용하는 것은 파일을 읽어와서 데이터를 한줄 단위로 쪼개고 데이터를 분류하여 . 출력한다고 생각하자 
# csv를 이용하는 것은 csv 모듈을 이용한 후에 csv.안에서 이용할 수 있는데.. csv.reader에서 delimiter는 데이터르 분류하는 기준 , quotechar 는 데이터를 묶을 때사용하는 문자이며, QUOTE_ALL +> 데이터를 묶는 기준으로 생각하자 ! 

# QUOTE_ALL은 자료형에 상관없이 묶는 것이며 모두 문자열로 처리함 !/ MINIMAL은 최소한의 데이터만 묶으며, ',' 같은 것으로 묶는 다고 생각하자 / NONNUMERIC => 숫자 데이터가 아닌 경우 묶이며, 묶이지 않은 데이터는 실수형으로 읽어옴 / NONE은 안하는 거임 !

# 로그 관리 

# 로깅은 로그를 관리하는 기법임 !/  기본 로그 관리 모듈은 logging이라는 것을 사용함 !/ debug => info -> warning -> error -> critical 순으로 사용 

# 디버그는 개발 시점의 프로그램이 문제가 없이 실행되는 확인하는 것임 print()와 비슷한 출력값이 나옴 
# 인포는 기본적으로 사용자에게 실행결과를 알려주는 로그 정보임 !
# 워닝은 문제가 될 수 있는 상황을 기록하는 것이다 !
# 에러와 크리티컬은 말그대로 에러가 발생하거나 프로그램이 더는 수행하기 어려울 때 발생하는 에러임! , 

# 설정 저장 

 # cofigparser argparse를 사용하는데 파이썬에서 수행할 수 있도록 지원하는 모듈이다 . / configparser는 설정 자체를 저장하는 것이며, argparse는 실행 시점의 설정 변수를 직접 지정시키는 것임 !!

 # configparser는 프로그램의 실행 설정값을 어떤 특정 파일에 저장하여 사용하는 방식임 ( 딕셔너리와 비슷하게 설정파일 안에 키와 값을 넣고 호출 하는 방식 !) / argparse는 프로그램을 콘솔 창에서 실행할 때 세팅을 설정하는 방식 

 # 웹 

 #http(인터넷에서 컴퓨터 간에 정보를 주고 받을 때의 사용하는 일종의 약속임 !!) 

 # 정규 표현식 ( 일종의 문자를 표현하는 공식 !!) 

 # 010-0000-0000 => ^\d{3}-\d{4}-\d{4}$
 # 123.123.123.122 => ^\d{1,3}.^\d{1,3}.^\d{1,3}.^\d{1,3}$
# . ^ $ * + ? {}[] \ | () 등이 사용되옵니다. 

# 기본 메타 문자 [] / 문자와 매칭하라는 뜻임 ! []에는 or의 쓰임도 있음 !! 
# 반복 관련 메타 문자 - , + , * , ? , {}

#[0-9][0-9][0-9][0-9][0-9][0-9[0-9][0-9][0-9]]
#[0-9]+-[0-9]+-[0-9]+ #여기서 +는 메타문자 - 는 메타문자가 아님 
#[0-9]{3}-[0-9]{3,4}-[0-9]{4}
#  * 는 +와 다르게 0~ 무한대까지 반복을 할 수 있음 / +는 1부터임 !!

#[.] => 일반적인 마침표 / (.) => 줄바꿈 기호를 제외한 전체문자 / | or ^는 or와 not에 의미로 많이 쓰임 ! , ^이 중간에 쓰이면 not으로 쓰임 !!
# 정규표현식 처음과 끝에는 메타문자인 ^이나 $를 주로 붙임 !!

# XML ( 확장적인 마크ㅇ업 언어 ! / 시작태그와 종료태그 사이의 값이 있고.. XML은 다양한 형태로 데이터를 표현할 수 있는 장점이 있음 !)
# JSON (데이터 교환 표준으로 삼은 데이터 표현 언어 ! / 파이썬의 딕셔너리형과 비슷 .. 키-값 의 쌍으로 구성되어있음 !)
# JSON은 import json을 사용함 !!/ loads()나 dump()등이 많이 쓰이며 loads는 문자열을 json 형태로 변환해주며, dump는 데이터를 저장한느 아이이다. 

# api는 일종의 함수로 해당회사가 제공하는 서비스를 활용하기 위한 함수 ! / json 데이터로도 많이 쓰임 


```
