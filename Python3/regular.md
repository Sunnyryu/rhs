# Rewind

```
[0~9]* 0부터 9까지 숫자가 0개 이상! 
[0~9]+ 0부터 9까지 1개 이상!

[0~9]?, 문자? =>  ?는 ? 앞의 문자(범위)가 0개 또는 1개인지 판단하고, .은 .이 있는 위치에 아무 문자(숫자)가 1개 있는지 판단합니다.


문자{개수}, (문자열){개수} => 

'[a-zA-Z0-9]는 a~z, A~Z, 0~9 이 사용가능!

[^범위]*, [^범위]+ => 범위를 제외한 문자가 있는 지 확인 !


특정 문자(숫자) 범위로 끝나는지 확인할 때는 정규표현식 뒤에 $를 붙이면 됩니다

\d: [0-9]와 같음. 모든 숫자
\D: [^0-9]와 같음. 숫자를 제외한 모든 문자
\w: [a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자
\W: [^a-zA-Z0-9_]와 같음. 영문 대소문자, 숫자, 밑줄 문자를 제외한 모든 문자
\s: [ \t\n\r\f\v]와 같음. 공백(스페이스), \t(탭) \n(새 줄, 라인 피드), \r(캐리지 리턴), \f(폼피드), \v(수직 탭)을 포함
\S: [^ \t\n\r\f\v]와 같음. 공백을 제외하고 \t, \n, \r, \f, \v만 포함


(정규표현식) (정규표현식) => 그룹으로 만듬 !!

ex) k = re.match('([0-9]+) ([0-9]+)', '10 295')
k.group(1) = '10'
k.group(2) = '295'
k.group() = '10 295'
k.group(0) = '10 295'

k.groups() 
('10', '295')

m = re.match('(?P<func>[a-zA-Z_][a-zA-Z0-9_]+)\((?P<arg>\w+)\)', 'print(1234)')
m.group('func')    # 그룹 이름으로 매칭된 문자열 출력
'print'
m.group('arg')     # 그룹 이름으로 매칭된 문자열 출력
'1234'

re.findall('패턴', '문자열')
re.findall('[0-9]+', '1 2 Fizz 4 Buzz Fizz 7 8') ['1', '2', '4', '7', '8']

 re.sub('apple|orange', 'fruit', 'apple box orange tree')    # apple 또는 orange를 fruit로 바꿈 => fruit box fruit tree'

def multiple10(m):        # 매개변수로 매치 객체를 받음
     n = int(m.group())    # 매칭된 문자열을 가져와서 정수로 변환
     return str(n * 10)    # 숫자에 10을 곱한 뒤 문자열로 변환해서 반환

re.sub('[0-9]+', multiple10, '1 2 Fizz 4 Buzz Fizz 7 8')
'10 20 Fizz 40 Buzz Fizz 70 80'

re.sub('([a-z]+) ([0-9]+)', '\\2 \\1 \\2 \\1', 'hello 1234')    # 그룹 2, 1, 2, 1 순으로 바꿈
'1234 hello 1234 hello'

re.sub('({\s*)"(\w+)":\s*"(\w+)"(\s*})', '<\\2>\\3</\\2>', '{ "name": "james" }')'<name>james</name>' (\\숫자)

\\g<이름>, \\g<숫자>

re.sub('({\s*)"(?P<key>\w+)":\s*"(?P<value>\w+)"(\s*})', '<\\g<key>>\\g<value></\\g<key>>', '{ "name": "james" }')
'<name>james</name>'




```
